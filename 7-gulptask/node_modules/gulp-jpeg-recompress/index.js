/*!
* gulp-pngquant-openmp | MIT (c) Shinnosuke Watanabe
* https://github.com/shinnn/gulp-pngquant-openmp
*/
'use strict';

const inspect = require('util').inspect;
const execa = require('execa');

const PluginError = require('gulp-util').PluginError;
const jpegRecompress = require('jpeg-recompress-bin');
const through = require('through2-concurrent');
const isVinyl = require('vinyl');

module.exports = function gulpJpegRecompress(options = {}) {
  return through.obj((file, enc, cb) => {
    if (!isVinyl(file)) {
      cb(new PluginError(
        'gulp-jpeg-recompress',
        inspect(file) +
        ' is not a vinyl object. Expected a vinyl object that contains PNG file data.'
      ));

      return;
    }

    if (file.isNull()) {
      cb(null, file);
      return;
    }

    if (file.isStream()) {
      cb(new PluginError('gulp-jpeg-recompress', 'Stream not supported.'));
      return;
    }

    const args = ['-'];
    const ret = [];
    const len = 0;

    if (options.floyd) {
      if (typeof options.floyd === 'number') {
        args.push('--floyd=' + options.floyd);
      }

      if (typeof options.floyd === 'boolean') {
        args.push('--floyd');
      }
    }

    if (options.nofs) {
      args.push('--nofs');
    }

    if (options.posterize) {
      args.push('--posterize', options.posterize);
    }

    if (options.quality) {
      args.push('--quality', options.quality);
    }

    if (options.speed) {
      args.push('--speed', options.speed);
    }

    if (options.verbose) {
      args.push('--verbose');
    }

    execa.stdout(jpegRecompress, args, {
      encoding: null,
      maxBuffer: Infinity
    }).then(buf => {
      if (buf.length < file.contents.length) {
        file.contents = Buffer.concat(ret, len);
      }

      cb(null, file);
    });
  });
};
